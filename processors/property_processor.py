"""
ูุนุงูุฌ ุงูุนูุงุฑุงุช - Property Processor
"""

import asyncio
from typing import List, Dict, Any, Optional, Tuple
from datetime import datetime, timedelta
from models.property import PropertyData, PropertyStatus
from services.telegram_service import TelegramService
from services.ai_service import AIService
from services.notion_service import NotionService
from services.zoho_service import ZohoService
from utils.database import DatabaseManager
from utils.logger import PropertyLogger, setup_logger
from config import Config

logger = setup_logger(__name__)

class PropertyProcessor:
    """ูุนุงูุฌ ุงูุนูุงุฑุงุช ุงูุฑุฆูุณู"""
    
    def __init__(self):
        self.config = Config()
        self.database = DatabaseManager(self.config.DATABASE_PATH)
        self.is_running = False
        
        # ุงูุฎุฏูุงุช
        self.telegram_service = None
        self.ai_service = None
        self.notion_service = None
        self.zoho_service = None
        
    async def start(self):
        """ุจุฏุก ุงููุนุงูุฌ"""
        try:
            # ุชููุฆุฉ ูุงุนุฏุฉ ุงูุจูุงูุงุช
            await self.database.initialize()
            
            # ุชููุฆุฉ ุงูุฎุฏูุงุช
            self.ai_service = AIService(self.config.ANTHROPIC_API_KEY)
            
            if self.config.NOTION_INTEGRATION_SECRET:
                self.notion_service = NotionService(
                    self.config.NOTION_INTEGRATION_SECRET,
                    self.config.NOTION_PROPERTIES_DB_ID,
                    self.config.NOTION_OWNERS_DB_ID
                )
            
            if self.config.ZOHO_CLIENT_ID:
                self.zoho_service = ZohoService(
                    self.config.ZOHO_CLIENT_ID,
                    self.config.ZOHO_CLIENT_SECRET,
                    self.config.ZOHO_REFRESH_TOKEN,
                    self.config.ZOHO_ACCESS_TOKEN
                )
            
            self.is_running = True
            logger.info("โ ุชู ุจุฏุก ูุนุงูุฌ ุงูุนูุงุฑุงุช")
            
        except Exception as e:
            logger.error(f"โ ุฎุทุฃ ูู ุจุฏุก ุงููุนุงูุฌ: {e}")
            raise
    
    async def stop(self):
        """ุฅููุงู ุงููุนุงูุฌ"""
        self.is_running = False
        if self.database:
            await self.database.close()
        logger.info("โ ุชู ุฅููุงู ูุนุงูุฌ ุงูุนูุงุฑุงุช")
    
    async def process_all_pending(self):
        """ูุนุงูุฌุฉ ุฌููุน ุงูุนูุงุฑุงุช ุงููุนููุฉ"""
        while self.is_running:
            try:
                # ุงูุญุตูู ุนูู ุงูุนูุงุฑุงุช ุงููุนููุฉ
                pending_properties = await self.database.get_pending_properties()
                
                if pending_properties:
                    logger.info(f"๐ ูุนุงูุฌุฉ {len(pending_properties)} ุนูุงุฑ ูุนูู")
                    
                    for property_data in pending_properties:
                        if not self.is_running:
                            break
                            
                        await self.process_property(property_data)
                        await asyncio.sleep(1)  # ุชููู ูุตูุฑ ุจูู ุงูุนูุงุฑุงุช
                
                # ุฌูุจ ุฑุณุงุฆู ุฌุฏูุฏุฉ ูู Telegram ุฅุฐุง ูุงู ูุชููุฑ
                if self.config.TELEGRAM_BOT_TOKEN:
                    await self.fetch_new_messages()
                
                # ุงูุชุธุงุฑ ูุจู ุงููุญุงููุฉ ุงูุชุงููุฉ
                await asyncio.sleep(self.config.PROCESSING_INTERVAL)
                
            except Exception as e:
                logger.error(f"โ ุฎุทุฃ ูู ุญููุฉ ุงููุนุงูุฌุฉ: {e}")
                await asyncio.sleep(60)  # ุงูุชุธุงุฑ ุฏูููุฉ ูู ุญุงูุฉ ุงูุฎุทุฃ
    
    async def fetch_new_messages(self):
        """ุฌูุจ ุฑุณุงุฆู ุฌุฏูุฏุฉ ูู Telegram"""
        try:
            async with TelegramService(
                self.config.TELEGRAM_BOT_TOKEN,
                self.config.TELEGRAM_CHANNEL_ID
            ) as telegram:
                
                messages = await telegram.get_channel_messages()
                
                for message in messages:
                    # ุงูุชุญูู ูู ุนุฏู ูุนุงูุฌุฉ ุงูุฑุณุงูุฉ ูุณุจูุงู
                    existing = await self.database.get_property_by_telegram_id(
                        message['message_id']
                    )
                    
                    if not existing and message['text'].strip():
                        # ุฅูุดุงุก ุนูุงุฑ ุฌุฏูุฏ ูู ุงูุฑุณุงูุฉ
                        property_data = PropertyData()
                        property_data.telegram_message_id = message['message_id']
                        property_data.raw_text = message['text']
                        property_data.status = PropertyStatus.PENDING
                        
                        # ุญูุธ ูู ูุงุนุฏุฉ ุงูุจูุงูุงุช
                        await self.database.save_property(property_data)
                        logger.info(f"๐ฅ ุชู ุงุณุชูุงู ุฑุณุงูุฉ ุฌุฏูุฏุฉ: {message['message_id']}")
        
        except Exception as e:
            logger.error(f"โ ุฎุทุฃ ูู ุฌูุจ ุงูุฑุณุงุฆู: {e}")
    
    async def process_property(self, property_data: PropertyData) -> bool:
        """ูุนุงูุฌุฉ ุนูุงุฑ ูุงุญุฏ"""
        
        property_logger = PropertyLogger(
            str(property_data.telegram_message_id or "unknown")
        )
        
        try:
            property_logger.log_processing_start(property_data.to_dict())
            
            # ุฒูุงุฏุฉ ุนุฏุฏ ุงููุญุงููุงุช
            property_data.processing_attempts += 1
            
            # ุงูุฎุทูุฉ 1: ุงุณุชุฎุฑุงุฌ ุงูุจูุงูุงุช ุจุงูุฐูุงุก ุงูุงุตุทูุงุนู
            if not property_data.ai_extracted and property_data.raw_text:
                success = await self._extract_data_with_ai(property_data, property_logger)
                if not success:
                    return await self._mark_as_failed(property_data, property_logger)
            
            # ุงูุฎุทูุฉ 2: ุงูุชุญูู ูู ุตุญุฉ ุงูุจูุงูุงุช
            is_valid, errors = property_data.is_valid()
            if not is_valid:
                property_logger.log_error("ุงูุชุญูู ูู ุงูุจูุงูุงุช", f"ุจูุงูุงุช ูุงูุตุฉ: {', '.join(errors)}")
                return await self._mark_as_failed(property_data, property_logger)
            
            # ุงูุฎุทูุฉ 3: ุชุตููู ุงูุนูุงุฑ
            classification = await self._classify_property(property_data, property_logger)
            
            # ุงูุฎุทูุฉ 4: ูุนุงูุฌุฉ ุญุณุจ ุงูุชุตููู
            success = await self._process_by_classification(
                property_data, classification, property_logger
            )
            
            if success:
                property_logger.log_processing_complete(True, property_data.status.value)
                return True
            else:
                return await self._mark_as_failed(property_data, property_logger)
                
        except Exception as e:
            property_logger.log_error("ูุนุงูุฌุฉ ุงูุนูุงุฑ", str(e))
            return await self._mark_as_failed(property_data, property_logger)
    
    async def _extract_data_with_ai(self, property_data: PropertyData, 
                                  property_logger: PropertyLogger) -> bool:
        """ุงุณุชุฎุฑุงุฌ ุงูุจูุงูุงุช ุจุงูุฐูุงุก ุงูุงุตุทูุงุนู"""
        
        try:
            property_logger.log_processing_step("ุงุณุชุฎุฑุงุฌ ุงูุจูุงูุงุช", "ุงุณุชุฎุฏุงู ุงูุฐูุงุก ุงูุงุตุทูุงุนู")
            
            extracted_data = await self.ai_service.extract_property_data(property_data.raw_text)
            
            if extracted_data:
                # ุชุญุฏูุซ ุจูุงูุงุช ุงูุนูุงุฑ
                temp_property = PropertyData.from_dict(extracted_data)
                
                # ูุณุฎ ุงูุจูุงูุงุช ุงููุณุชุฎุฑุฌุฉ
                property_data.region = temp_property.region
                property_data.unit_code = temp_property.unit_code
                property_data.unit_type = temp_property.unit_type
                property_data.unit_condition = temp_property.unit_condition
                property_data.area = temp_property.area
                property_data.floor = temp_property.floor
                property_data.price = temp_property.price
                property_data.features = temp_property.features
                property_data.address = temp_property.address
                property_data.employee_name = temp_property.employee_name
                property_data.owner_name = temp_property.owner_name
                property_data.owner_phone = temp_property.owner_phone
                property_data.availability = temp_property.availability
                property_data.photos_status = temp_property.photos_status
                property_data.full_details = temp_property.full_details
                
                # ุฅูุดุงุก ุงูุจูุงู
                property_data.generate_statement()
                property_data.ai_extracted = True
                
                property_logger.log_success("ุงุณุชุฎุฑุงุฌ ุงูุจูุงูุงุช", "ุชู ุจูุฌุงุญ")
                return True
            else:
                property_logger.log_error("ุงุณุชุฎุฑุงุฌ ุงูุจูุงูุงุช", "ูุดู ูู ุงุณุชุฎุฑุงุฌ ุงูุจูุงูุงุช")
                return False
                
        except Exception as e:
            property_logger.log_error("ุงุณุชุฎุฑุงุฌ ุงูุจูุงูุงุช", str(e))
            return False
    
    async def _classify_property(self, property_data: PropertyData, 
                               property_logger: PropertyLogger) -> str:
        """ุชุตููู ุงูุนูุงุฑ"""
        
        try:
            property_logger.log_processing_step("ุชุตููู ุงูุนูุงุฑ")
            
            # ุงูุจุญุซ ุนู ุนูุงุฑุงุช ููุฑุฑุฉ
            duplicate_properties = await self.database.find_duplicate_properties(property_data)
            
            if duplicate_properties:
                # ุนูุงุฑ ููุฑุฑ
                property_logger.log_classification("ุนูุงุฑ ููุฑุฑ", "ูุฌุฏ ุนูุงุฑ ูุทุงุจู ุชูุงูุงู")
                return "ุนูุงุฑ ููุฑุฑ"
            
            # ุงูุจุญุซ ุนู ุนูุงุฑุงุช ูููุงูู ููุณู
            owner_properties = await self.database.find_owner_properties(property_data.owner_phone)
            
            if owner_properties:
                # ุนูุงุฑ ูุชุนุฏุฏ
                property_logger.log_classification("ุนูุงุฑ ูุชุนุฏุฏ", "ูุงูู ูุฏูู ุนูุงุฑุงุช ุฃุฎุฑู")
                return "ุนูุงุฑ ูุชุนุฏุฏ"
            
            # ุนูุงุฑ ุฌุฏูุฏ
            property_logger.log_classification("ุนูุงุฑ ุฌุฏูุฏ", "ูุงูู ูููุงุตูุงุช ุฌุฏูุฏุฉ")
            return "ุนูุงุฑ ุฌุฏูุฏ"
            
        except Exception as e:
            property_logger.log_error("ุชุตููู ุงูุนูุงุฑ", str(e))
            return "ุนูุงุฑ ุฌุฏูุฏ"  # ุงูุชุฑุงุถู
    
    async def _process_by_classification(self, property_data: PropertyData, 
                                       classification: str, 
                                       property_logger: PropertyLogger) -> bool:
        """ูุนุงูุฌุฉ ุงูุนูุงุฑ ุญุณุจ ุงูุชุตููู"""
        
        try:
            if classification == "ุนูุงุฑ ุฌุฏูุฏ":
                return await self._process_new_property(property_data, property_logger)
            
            elif classification == "ุนูุงุฑ ูุชุนุฏุฏ":
                return await self._process_multiple_property(property_data, property_logger)
            
            elif classification == "ุนูุงุฑ ููุฑุฑ":
                return await self._process_duplicate_property(property_data, property_logger)
            
            else:
                property_logger.log_error("ุงููุนุงูุฌุฉ", f"ุชุตููู ุบูุฑ ูุนุฑูู: {classification}")
                return False
                
        except Exception as e:
            property_logger.log_error("ุงููุนุงูุฌุฉ ุญุณุจ ุงูุชุตููู", str(e))
            return False
    
    async def _process_new_property(self, property_data: PropertyData, 
                                  property_logger: PropertyLogger) -> bool:
        """ูุนุงูุฌุฉ ุนูุงุฑ ุฌุฏูุฏ"""
        
        try:
            # ุฅูุดุงุก ุตูุญุฉ ูุงูู ูู Notion
            owner_id = None
            if self.notion_service:
                owner_id = await self.notion_service.create_owner_page(property_data.to_dict())
                property_data.notion_owner_id = owner_id
                property_logger.log_success("ุฅูุดุงุก ุตูุญุฉ ุงููุงูู", f"Notion ID: {owner_id}")
            
            # ุฅูุดุงุก ุตูุญุฉ ุนูุงุฑ ูู Notion
            if self.notion_service:
                property_id = await self.notion_service.create_property_page(
                    property_data.to_dict(), owner_id
                )
                property_data.notion_property_id = property_id
                property_logger.log_success("ุฅูุดุงุก ุตูุญุฉ ุงูุนูุงุฑ", f"Notion ID: {property_id}")
            
            # ุฅุฑุณุงู ุงูุจูุงูุงุช ุฅูู Zoho
            if self.zoho_service:
                async with self.zoho_service as zoho:
                    lead_id = await zoho.create_lead(property_data.to_dict())
                    property_data.zoho_lead_id = lead_id
                    property_logger.log_success("ุฅูุดุงุก ุงูุนููู", f"Zoho ID: {lead_id}")
            
            # ุชุญุฏูุซ ุงูุญุงูุฉ
            property_data.status = PropertyStatus.SUCCESSFUL
            await self.database.update_property(
                property_data.telegram_message_id, property_data
            )
            
            # ุฅุฑุณุงู ุฅุดุนุงุฑ
            await self._send_notification(property_data, "ุนูุงุฑ ุฌุฏูุฏ", property_logger)
            
            return True
            
        except Exception as e:
            property_logger.log_error("ูุนุงูุฌุฉ ุงูุนูุงุฑ ุงูุฌุฏูุฏ", str(e))
            return False
    
    async def _process_multiple_property(self, property_data: PropertyData, 
                                       property_logger: PropertyLogger) -> bool:
        """ูุนุงูุฌุฉ ุนูุงุฑ ูุชุนุฏุฏ"""
        
        try:
            # ุงูุจุญุซ ุนู ุงููุงูู ุงูููุฌูุฏ
            existing_owner = None
            if self.notion_service:
                existing_owner = await self.notion_service.search_owner(property_data.owner_phone)
            
            # ุฅูุดุงุก ุตูุญุฉ ุนูุงุฑ ุฌุฏูุฏุฉ ูุฑุชุจุทุฉ ุจุงููุงูู ุงูููุฌูุฏ
            if self.notion_service and existing_owner:
                property_id = await self.notion_service.create_property_page(
                    property_data.to_dict(), existing_owner['id']
                )
                property_data.notion_property_id = property_id
                property_data.notion_owner_id = existing_owner['id']
                
                # ุชุญุฏูุซ ุนุฏุฏ ุนูุงุฑุงุช ุงููุงูู
                await self.notion_service.update_owner_properties_count(existing_owner['id'])
                
                property_logger.log_success("ุฑุจุท ุงูุนูุงุฑ ุจุงููุงูู", f"Property: {property_id}")
            
            # ุฅุฑุณุงู ุงูุจูุงูุงุช ุฅูู Zoho
            if self.zoho_service:
                async with self.zoho_service as zoho:
                    # ุงูุจุญุซ ุนู ุงูุนููู ุงูููุฌูุฏ
                    existing_lead = await zoho.search_lead(property_data.owner_phone)
                    
                    if existing_lead:
                        # ุชุญุฏูุซ ุงูุจูุงูุงุช ุงูููุฌูุฏุฉ
                        await zoho.update_lead(existing_lead['id'], property_data.to_dict())
                        property_data.zoho_lead_id = existing_lead['id']
                        property_logger.log_success("ุชุญุฏูุซ ุงูุนููู", f"Zoho ID: {existing_lead['id']}")
                    else:
                        # ุฅูุดุงุก ุนููู ุฌุฏูุฏ
                        lead_id = await zoho.create_lead(property_data.to_dict())
                        property_data.zoho_lead_id = lead_id
                        property_logger.log_success("ุฅูุดุงุก ุงูุนููู", f"Zoho ID: {lead_id}")
            
            # ุชุญุฏูุซ ุงูุญุงูุฉ
            property_data.status = PropertyStatus.SUCCESSFUL
            await self.database.update_property(
                property_data.telegram_message_id, property_data
            )
            
            # ุฅุฑุณุงู ุฅุดุนุงุฑ
            await self._send_notification(property_data, "ุนูุงุฑ ูุชุนุฏุฏ", property_logger)
            
            return True
            
        except Exception as e:
            property_logger.log_error("ูุนุงูุฌุฉ ุงูุนูุงุฑ ุงููุชุนุฏุฏ", str(e))
            return False
    
    async def _process_duplicate_property(self, property_data: PropertyData, 
                                        property_logger: PropertyLogger) -> bool:
        """ูุนุงูุฌุฉ ุนูุงุฑ ููุฑุฑ"""
        
        try:
            # ุงูุจุญุซ ุนู ุงูุนูุงุฑ ุงููุทุงุจู
            duplicate_properties = await self.database.find_duplicate_properties(property_data)
            similar_property = duplicate_properties[0] if duplicate_properties else None
            
            # ุชุญุฏูุซ ุงูุญุงูุฉ
            property_data.status = PropertyStatus.DUPLICATE
            await self.database.update_property(
                property_data.telegram_message_id, property_data
            )
            
            # ุฅุฑุณุงู ุฅุดุนุงุฑ ูุน ุฑุงุจุท ุงูุนูุงุฑ ุงููุดุงุจู
            similar_link = ""
            if similar_property and similar_property.notion_property_id:
                similar_link = f"https://www.notion.so/{similar_property.notion_property_id.replace('-', '')}"
            
            await self._send_notification(
                property_data, "ุนูุงุฑ ููุฑุฑ", property_logger, similar_link
            )
            
            property_logger.log_success("ูุนุงูุฌุฉ ุงูุนูุงุฑ ุงูููุฑุฑ", "ุชู ุงูุฅุดุนุงุฑ ุจุงูุชูุฑุงุฑ")
            return True
            
        except Exception as e:
            property_logger.log_error("ูุนุงูุฌุฉ ุงูุนูุงุฑ ุงูููุฑุฑ", str(e))
            return False
    
    async def _mark_as_failed(self, property_data: PropertyData, 
                            property_logger: PropertyLogger) -> bool:
        """ูุณู ุงูุนูุงุฑ ููุงุดู"""
        
        try:
            property_data.status = PropertyStatus.FAILED
            property_data.update_timestamp()
            
            await self.database.update_property(
                property_data.telegram_message_id, property_data
            )
            
            # ุฅุฑุณุงู ุฅุดุนุงุฑ ูุดู
            await self._send_notification(property_data, "ุนูุงุฑ ูุงุดู", property_logger)
            
            property_logger.log_processing_complete(False, "ุนูุงุฑ ูุงุดู")
            return True
            
        except Exception as e:
            property_logger.log_error("ูุณู ุงูุนูุงุฑ ููุงุดู", str(e))
            return False
    
    async def _send_notification(self, property_data: PropertyData, 
                               classification: str, property_logger: PropertyLogger,
                               similar_link: str = "") -> bool:
        """ุฅุฑุณุงู ุฅุดุนุงุฑ"""
        
        try:
            if not self.config.TELEGRAM_BOT_TOKEN:
                return True  # ูุง ููุฌุฏ ุจูุช ููุฅุดุนุงุฑุงุช
            
            async with TelegramService(
                self.config.TELEGRAM_BOT_TOKEN,
                self.config.TELEGRAM_CHANNEL_ID
            ) as telegram:
                
                message = telegram.format_property_notification(
                    property_data.to_dict(), classification, similar_link
                )
                
                success = await telegram.send_message(message)
                
                if success:
                    property_logger.log_success("ุฅุฑุณุงู ุงูุฅุดุนุงุฑ", classification)
                else:
                    property_logger.log_error("ุฅุฑุณุงู ุงูุฅุดุนุงุฑ", "ูุดู ูู ุงูุฅุฑุณุงู")
                
                return success
                
        except Exception as e:
            property_logger.log_error("ุฅุฑุณุงู ุงูุฅุดุนุงุฑ", str(e))
            return False
